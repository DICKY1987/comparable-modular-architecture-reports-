NW_Complete Modular Architecture
TIER 1: CORE MODULES (Sacred/Privileged)
Module 1: Pipeline Orchestrator
Purpose: Main event loop; dispatches lifecycle events to plugins
Deliverables:
•
•
•
•
•
•

core/orchestrator.py - Main runner process
core/event_dispatcher.py - Routes events to registered plugins
core/plugin_loader.py - Discovers and loads valid plugins

Event schemas (JSON) for each lifecycle hook
Startup/shutdown procedures
Error isolation wrappers (catch plugin failures)

Key Contracts:
dispatch_event(event_name: str, payload: dict) -> list[PluginProposal]
load_plugins(registry_path: Path) -> dict[str, Plugin]
isolate_execution(plugin: Plugin, event: Event) -> Result

Module 2: Ledger Manager
Purpose: Append-only audit trail; ULID assignment; provenance tracking
Deliverables:
•
•
•
•
•
•

core/ledger_writer.py - JSONL append-only writer
core/ledger_query.py - Query interface (read-only)
core/ulid_generator.py - ULID creation with Two-ID system
.runs/ledger.jsonl - Main ledger file

Ledger schema validation (JSON Schema)
Rollback reference index

Key Contracts:
write_entry(event: Event, actor: str, proposals: list, result: Result) ->
ULID
query_by_ulid(ulid: str) -> LedgerEntry
query_by_timerange(start: datetime, end: datetime) -> list[LedgerEntry]
get_rollback_target(ulid: str) -> dict # before-state snapshot

Module 3: Git Operations Manager
Purpose: All Git commands; branch creation; merge execution; snapshot tagging
Deliverables:
•
•
•
•
•
•

core/git_ops.py - Git command wrappers
core/branch_manager.py - Reconciliation branch logic
core/snapshot_tagger.py - Tag rollback points
core/merge_executor.py - Applies approved merge strategies
Git config templates (.gitattributes, .gitconfig)
Merge policy schema (policy_pack.json)

Key Contracts:
create_reconcile_branch(name: str, base: str) -> Branch
merge_with_strategy(source: Branch, target: Branch, strategy: str) ->
MergeResult
tag_rollback_point(commit_sha: str, ulid: str) -> Tag
restore_to_snapshot(tag: str) -> RestoreResult

Module 4: Sync Guardian
Purpose: Local ↔ GitHub reconciliation; conflict-free sync
Deliverables:
•
•
•
•
•

core/sync_auditor.py - Generates reconciliation reports
core/sync_reconciler.py - Creates sync branches
.runs/sync/<ULID>.json - Sync reports (timestamped)

Sync policy rules (what triggers sync)
Collision detection logic

Key Contracts:
audit_sync_state() -> SyncReport # local-only, remote-only, conflicts
create_sync_branch(report: SyncReport) -> Branch
reconcile_differences(sync_branch: Branch) -> ReconcileResult

Report Schema:
{
"local_only_files": ["path/to/file.py"],
"remote_only_commits": ["abc123"],
"conflicts": [{"path": "...", "reason": "both_modified"}],
"recommended_action": "merge_remote_first"
}

Module 5: Plugin Registry & Loader
Purpose: Discover plugins; validate against contract; maintain enabled list
Deliverables:
•
•
•
•
•

core/plugin_registry.py - Central registry of all plugins
core/plugin_validator.py - Pre-flight checks
plugins/registry.json - List of enabled plugins

Plugin lifecycle hooks mapping
Plugin dependency resolution

Key Contracts:
discover_plugins(plugins_dir: Path) -> list[PluginSpec]
validate_plugin(plugin_path: Path) -> ValidationResult
register_plugin(spec: PluginSpec) -> bool
get_plugins_for_event(event_name: str) -> list[Plugin]

Module 6: Validator Engine
Purpose: Enforce Operating Contract; reject non-compliant plugins
Deliverables:
•
•
•
•
•

core/validate_plugin.py - Main validation script

Validation rules library
core/contract_checker.py - Checks against OPERATING_CONTRACT.md

Validation report templates
SafePatch region detector

Key Contracts:
validate_plugin_structure(plugin_dir: Path) -> ValidationResult
check_required_artifacts(plugin_dir: Path) -> list[str] # missing files
validate_handler_signature(handler_file: Path, event: str) -> bool
check_safepatch_boundaries(handler_file: Path) -> bool
static_security_scan(handler_file: Path) -> list[SecurityViolation]

Module 7: Generator/Scaffold Engine
Purpose: Creates complete plugin skeletons from plugin.spec.json

Deliverables:
•
•
•

core/generate_plugin_scaffold.py - Main generator
core/templates/ - Template files for each artifact

Generated artifacts per plugin:
o
o
o
o
o
o

manifest.json
policy_snapshot.json
ledger_contract.json
README_PLUGIN.md
healthcheck.md
handler.py or handler.ps1 (with AUTO regions)

Key Contracts:
generate_scaffold(spec_file: Path) -> Path # returns plugin directory
render_template(template: str, context: dict) -> str
create_handler_stub(event: str, language: str) -> str
generate_all_docs(spec: PluginSpec) -> dict[str, str] # filename -> content

Module 8: Policy Enforcement Engine
Purpose: Reads policy_pack.json; enforces allowed actions per event
Deliverables:
•
•
•
•

core/policy_enforcer.py - Policy checker
core/policy_pack.json - Machine-readable policy rules

Policy schema validation
Action allowlist/denylist per lifecycle event

Key Contracts:
load_policy(policy_file: Path) -> Policy
check_proposal(proposal: Proposal, event: str, policy: Policy) -> bool
get_allowed_actions(event: str) -> list[str]

Policy Schema Example:
{
"lifecycle_events": {
"FileDetected": {
"allowed_actions": ["propose_move", "propose_quarantine",
"propose_dedupe"],
"forbidden_actions": ["delete_permanent", "commit_direct"]
}
}
}

TIER 2: PLUGIN MODULES (Extensible/Evolvable)
Module 9: File Classifier/Organizer
Purpose: Analyze files; determine correct module placement
Deliverables:
•
•
•
•
•

plugins/file-classifier/handler.py
plugins/file-classifier/module_registry.json - Keywords per module

Classification logic (keyword matching)
Deduplication rules (mtime, size, hash)
All standard artifacts (manifest, policy snapshot, etc.)

Lifecycle Event: FileDetected
Input Contract:
{
"event": "FileDetected",
"inputs": {
"path": "new_file.py",
"hash": "sha256:abc...",
"size": 1234,
"mime": "text/x-python",
"mtime": "2025-10-27T12:00:00Z"
}
}

Output Contract (Proposals):
[
{
"action": "propose_move",
"payload": {
"from": "new_file.py",
"to": "Goal_Normalizer_MOD/new_file.py",
"confidence": 0.85,
"reasoning": "File contains 'normalize' and 'goal' keywords"
}
}
]

Module 10: Conflict Resolver Suite
Purpose: Deterministic conflict resolution strategies
Deliverables:

•
•
•
•
•

plugins/conflict-resolver-ours/handler.py - "Take ours" strategy
plugins/conflict-resolver-theirs/handler.py - "Take theirs" strategy
plugins/conflict-resolver-smart-merge/handler.py - Content-aware merge

Strategy priority configuration
Conflict pattern library

Lifecycle Event: MergeConflict
Input Contract:
{
"event": "MergeConflict",
"inputs": {
"file": "src/config.py",
"ours_content": "...",
"theirs_content": "...",
"base_content": "...",
"conflict_type": "content"
}
}

Output Contract:
[
{
"action": "propose_resolution",
"payload": {
"strategy": "take_ours",
"confidence": 0.9,
"reasoning": "Local changes newer and tested",
"risk_factors": []
}
}
]

Module 11: Pre-Merge Quality Gates
Purpose: Run checks before allowing merge
Deliverables:
•
•
•
•
•

plugins/pre-merge-lint/handler.py - Linting check
plugins/pre-merge-test/handler.py - Test runner
plugins/pre-merge-format/handler.py - Code formatter

Integration with Ruff, Black, Pylint, PSScriptAnalyzer
Pass/fail/warn reporting

Lifecycle Event: PreMerge

Input Contract:
{
"event": "PreMerge",
"inputs": {
"source_branch": "feature/new-thing",
"target_branch": "main",
"files_changed": ["src/foo.py", "src/bar.py"]
}
}

Output Contract:
[
{
"action": "propose_gate_result",
"payload": {
"gate_name": "lint",
"status": "pass",
"details": {"violations": 0},
"blocking": false
}
}
]

Module 12: Post-Merge Validators
Purpose: Verify merge success; trigger notifications
Deliverables:
•
•
•
•

plugins/post-merge-notify/handler.py - Notification sender
plugins/post-merge-validate/handler.py - Schema/syntax check
plugins/post-merge-cleanup/handler.py - Temp branch deletion

Integration with Slack/Discord/email

Lifecycle Event: PostMerge

Module 13: Quarantine Manager
Purpose: Handle failed/ambiguous operations
Deliverables:
•
•

plugins/quarantine-handler/handler.py
Quarantine directory structure (QUARANTINE_UNCLASSIFIED/, etc.)

•
•

Review instructions generator
Pattern signature extractor (for future learning)

Lifecycle Event: QuarantineCreated

Module 14: Auto-Fix/Format Suite
Purpose: Automated corrections for known issues
Deliverables:
•
•
•
•

plugins/auto-fix-imports/handler.py - Import sorting (isort)
plugins/auto-fix-whitespace/handler.py - Trailing whitespace
plugins/auto-fix-formatting/handler.py - Black/Ruff auto-fix

Known issue pattern library

Lifecycle Event: FileDetected or PreMerge

Module 15: Observability/Metrics
Purpose: Health monitoring; performance tracking
Deliverables:
•
•
•
•

plugins/observability-health/handler.py - System health checks
plugins/observability-metrics/handler.py - Performance metrics

Dashboard data exporter (JSON)
Alert threshold configuration

Lifecycle Event: PostMerge or periodic timer

TIER 3: SUPPORT MODULES
Module 16: Module Registry
Purpose: Central knowledge base of all modules and their domains
Deliverables:

•
•
•

core/module_registry.json - Keywords, paths, extensions per module
core/registry_updater.py - Add/remove modules

Registry schema validation

Schema Example:
{
"Goal_Normalizer_..._MOD": {
"keywords": ["normalize", "goal", "capability", "constraint"],
"allowed_extensions": [".py", ".ps1", ".md"],
"path": "Goal_Normalizer_..._MOD/"
}
}

Module 17: Documentation Generator
Purpose: Living docs that sync with implementation
Deliverables:
•
•
•

core/doc_generator.py - Template-based doc creation

Templates for README, healthcheck, policy snapshot
Markdown rendering utilities

Module 18: Testing Framework
Purpose: Validate plugins and core in isolation
Deliverables:
•
•
•
•
•

tests/test_orchestrator.py - Core orchestrator tests
tests/test_plugin_loader.py - Plugin loading tests
tests/test_lifecycle_events.py - Event dispatch tests

Per-plugin test template
Mock event fixtures

Complete Deliverables Summary by Module

Module

Generated
Artifacts

Core Files

Pipeline
orchestrator.py,
Orchestrat
event_dispatcher.py
or
Ledger
ledger_writer.py,
Manager ledger_query.py
Git
git_ops.py,
Operations merge_executor.py
Sync
sync_auditor.py
Guardian
Plugin
plugin_registry.py
Registry

Config Files

Tests
test_orchestrator.p
y

Event schemas

-

.runs/ledger.jsonl

ledger_schema.jso
test_ledger.py
n

Merge reports

.gitattributes

.runs/sync/*.json sync_policy.yaml

test_git_ops.py
test_sync.py

plugins/registry.js
test_registry.py
on
Validation
validation_rules.js
Validator validate_plugin.py
test_validator.py
reports
on
generate_plugin_scaffol All plugin
Generator
templates/
test_generator.py
d.py
artifacts
Policy
policy_enforcer.py
policy_pack.json test_policy.py
Enforcer
File
manifest.json + 5 module_registry.js test_file_classifier
plugins/file-classifier/*
Classifier
others
on
.py
Conflict
strategy_priority.y
plugins/conflict-/
6 artifacts each
test_conflicts.py
Resolvers
aml
Quality
gate_thresholds.ya
plugins/pre-merge-/
6 artifacts each
test_gates.py
Gates
ml

Module Dependencies
Pipeline Orchestrator
├── Plugin Registry (loads plugins)
├── Ledger Manager (writes audit trail)
├── Git Operations (executes approved actions)
├── Policy Enforcer (validates proposals)
└── Event Dispatcher → All Plugins
Sync Guardian
├── Git Operations (for fetch/merge)
└── Ledger Manager (logs sync actions)
Generator
├── Validator (checks generated artifacts)
└── Module Registry (for classification hints)
All Plugins
├── Ledger Manager (via core interface)

└── Policy Enforcer (action validation)

Integration Points
External Tool Integration:
•
•
•
•

Aider + DeepSeek - Called by code-editing plugins
Claude Code CLI - Task planning, codebase analysis
Ruff/Black/Pylint - Called by quality gate plugins
GitHub CLI - Called by Sync Guardian for remote ops

Data Flows:
1. File appears → Orchestrator detects → Dispatches FileDetected → File Classifier
proposes → Core executes → Ledger records
2. Merge conflict → Git Ops detects → Dispatches MergeConflict → Resolvers propose
→ Core applies best → Ledger records
3. Sync needed → Sync Guardian audits → Creates sync branch → Reconciles → Merges
→ Ledger records

This modular architecture ensures:
•
•
•
•
•
•

Clear separation of concerns
Each module has single responsibility
Plugins can't break core
AI can safely generate new plugins
Complete audit trail
Deterministic and reversible

